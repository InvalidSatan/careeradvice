<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Mountain Race with Improved Obstacles</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { display: block; }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    <script>
        // Initialize Pixi Application
        const app = new PIXI.Application({
            width: 800,
            height: 600,
            backgroundColor: 0x87CEEB,
        });
        document.getElementById('gameCanvas').appendChild(app.view);

        // Game variables
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const MOVE_SPEED = 3;
        const AI_DECISION_RATE = 10; // Make decisions more frequently

        // Create game containers
        const worldContainer = new PIXI.Container();
        const backgroundContainer = new PIXI.Container();
        const terrainContainer = new PIXI.Container();
        const obstacleContainer = new PIXI.Container();
        const playerContainer = new PIXI.Container();
        worldContainer.addChild(backgroundContainer, terrainContainer, obstacleContainer, playerContainer);
        app.stage.addChild(worldContainer);

        // AI Players
        function createPlayer(color, x) {
            const player = new PIXI.Graphics();
            player.beginFill(color);
            player.drawRect(-15, -25, 30, 50);
            player.endFill();
            player.x = x;
            player.y = app.screen.height - 50;
            player.vy = 0;
            player.jumping = false;
            player.score = 0;
            playerContainer.addChild(player);
            return player;
        }

        const player1 = createPlayer(0xFF0000, 100); // Red player
        const player2 = createPlayer(0x0000FF, 50);  // Blue player

        // Terrain and Obstacles
        const terrainWidth = 50000;
        const terrainResolution = 100;
        const terrainPoints = [];
        const obstacles = [];
        let terrainGraphics;

        // Game state
        let gameState = 'start';
        let cameraX = 0;

        // Generate smooth terrain with obstacles
        function generateTerrain() {
            terrainPoints.length = 0;
            obstacles.length = 0;
            let y = app.screen.height - 100;

            for (let x = 0; x < terrainWidth; x += terrainResolution) {
                y += (Math.random() - 0.5) * 50;
                y = Math.max(100, Math.min(app.screen.height - 50, y));
                terrainPoints.push(new PIXI.Point(x, y));

                // Add obstacles randomly
                if (Math.random() < 0.1 && x > 1000) { // Start adding obstacles after 1000px
                    obstacles.push({
                        x: x,
                        y: y - 40, // Place obstacle slightly higher above the ground
                        width: 30,
                        height: 40
                    });
                }
            }

            // Ensure the terrain slopes upward overall
            for (let i = 1; i < terrainPoints.length; i++) {
                terrainPoints[i].y = Math.min(terrainPoints[i].y, terrainPoints[i-1].y + 20);
            }
        }

        // Draw terrain and obstacles
        function drawTerrainAndObstacles() {
            if (terrainGraphics) {
                terrainContainer.removeChild(terrainGraphics);
            }
            obstacleContainer.removeChildren();

            terrainGraphics = new PIXI.Graphics();

            // Draw terrain body
            terrainGraphics.beginFill(0x5b3e26);
            terrainGraphics.moveTo(terrainPoints[0].x, app.screen.height);
            terrainPoints.forEach(point => terrainGraphics.lineTo(point.x, point.y));
            terrainGraphics.lineTo(terrainPoints[terrainPoints.length - 1].x, app.screen.height);
            terrainGraphics.endFill();

            // Draw grass
            terrainGraphics.lineStyle(2, 0x2e8b57);
            for (let i = 0; i < terrainPoints.length - 1; i++) {
                const x1 = terrainPoints[i].x;
                const y1 = terrainPoints[i].y;
                const x2 = terrainPoints[i + 1].x;
                const y2 = terrainPoints[i + 1].y;

                for (let j = 0; j < 5; j++) {
                    const x = x1 + (x2 - x1) * (j / 5);
                    const y = y1 + (y2 - y1) * (j / 5);
                    terrainGraphics.moveTo(x, y);
                    terrainGraphics.lineTo(x, y - Math.random() * 5 - 2);
                }
            }

            terrainContainer.addChild(terrainGraphics);

            // Draw obstacles
            obstacles.forEach(obstacle => {
                const obstacleGraphics = new PIXI.Graphics();
                obstacleGraphics.beginFill(0xFF0000); // Changed to red for better visibility
                obstacleGraphics.drawRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                obstacleGraphics.endFill();
                obstacleContainer.addChild(obstacleGraphics);
            });
        }

        // Background with parallax effect
        function createBackground() {
            const skyGradient = new PIXI.Graphics();
            skyGradient.beginFill(0x87CEEB);
            skyGradient.drawRect(0, 0, terrainWidth, app.screen.height);
            skyGradient.endFill();
            backgroundContainer.addChild(skyGradient);

            for (let i = 0; i < terrainWidth / 500; i++) {
                const mountain = new PIXI.Graphics();
                mountain.beginFill(0x6a8ea6);
                mountain.moveTo(0, app.screen.height);
                for (let x = 0; x <= 600; x++) {
                    const y = Math.sin(x / 100 + i) * 50 + Math.sin(x / 50) * 25;
                    mountain.lineTo(x, app.screen.height - 100 - y);
                }
                mountain.lineTo(600, app.screen.height);
                mountain.endFill();
                mountain.x = i * 500;
                mountain.tint = 0x6a8ea6 - (i % 3) * 0x111111; // Vary mountain colors slightly
                backgroundContainer.addChild(mountain);
            }
        }

        // Check for collision with obstacles
        function checkObstacleCollision(player) {
            return obstacles.some(obstacle =>
                player.x + 15 > obstacle.x &&
                player.x - 15 < obstacle.x + obstacle.width &&
                player.y > obstacle.y &&
                player.y - 50 < obstacle.y + obstacle.height
            );
        }

        // AI decision making
        function makeAIDecision(player, otherPlayer) {
            const terrainIndex = Math.floor(player.x / terrainResolution);
            const nextTerrainIndex = Math.floor((player.x + 100) / terrainResolution);

            if (terrainIndex >= 0 && terrainIndex < terrainPoints.length &&
                nextTerrainIndex >= 0 && nextTerrainIndex < terrainPoints.length) {
                const currentHeight = terrainPoints[terrainIndex].y;
                const nextHeight = terrainPoints[nextTerrainIndex].y;

                // Check for nearby obstacles
                const nearbyObstacle = obstacles.find(obstacle =>
                    obstacle.x > player.x && obstacle.x < player.x + 200
                );

                // Jump if approaching a higher terrain, to catch up with the other player, or to avoid an obstacle
                if ((nextHeight < currentHeight - 10 || otherPlayer.x > player.x + 50 || nearbyObstacle) && !player.jumping) {
                    player.vy = JUMP_FORCE;
                    player.jumping = true;
                }
            }
        }

        // Update game state
        function update(delta) {
            if (gameState === 'playing') {
                [player1, player2].forEach((player, index) => {
                    // Apply gravity
                    player.vy += GRAVITY;
                    player.y += player.vy;

                    // Move player
                    player.x += MOVE_SPEED;

                    // Check ground collision
                    const terrainIndex = Math.floor(player.x / terrainResolution);
                    if (terrainIndex >= 0 && terrainIndex < terrainPoints.length) {
                        const groundHeight = terrainPoints[terrainIndex].y;
                        if (player.y > groundHeight) {
                            player.y = groundHeight;
                            player.vy = 0;
                            player.jumping = false;
                        }
                    }

                    // Check obstacle collision
                    if (checkObstacleCollision(player)) {
                        player.x -= MOVE_SPEED * 5; // Push player back more
                        player.score = Math.max(0, player.score - 10); // Bigger penalty for hitting an obstacle
                    }

                    // AI decision making
                    if (app.ticker.lastTime % AI_DECISION_RATE === 0) {
                        makeAIDecision(player, index === 0 ? player2 : player1);
                    }

                    // Update score
                    player.score = Math.max(0, Math.floor(player.x / 10));
                });

                // Update camera position to follow the leading player
                const leadingPlayer = player1.x > player2.x ? player1 : player2;
                cameraX = leadingPlayer.x - app.screen.width / 3;
                worldContainer.x = -cameraX;
                backgroundContainer.x = -cameraX * 0.5; // Parallax effect

                // Check for game over condition
                if (Math.max(player1.x, player2.x) >= terrainWidth - 100) {
                    gameState = 'gameOver';
                }
            }
        }

        // Setup game
        function setup() {
            createBackground();
            generateTerrain();
            drawTerrainAndObstacles();

            app.ticker.add(update);

            // Event listeners
            window.addEventListener('click', startGame);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    startGame();
                }
            });
        }

        function startGame() {
            if (gameState === 'start' || gameState === 'gameOver') {
                gameState = 'playing';
                player1.x = 100;
                player1.y = app.screen.height - 50;
                player1.vy = 0;
                player1.score = 0;
                player2.x = 50;
                player2.y = app.screen.height - 50;
                player2.vy = 0;
                player2.score = 0;
                cameraX = 0;
                worldContainer.x = 0;
                backgroundContainer.x = 0;
            }
        }

        // Start the game
        setup();
    </script>
</body>
</html>