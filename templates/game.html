<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Mountain Race with Advanced AI</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { display: block; }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    <script>
        // Initialize Pixi Application
        const app = new PIXI.Application({
            width: 800,
            height: 600,
            backgroundColor: 0x87CEEB,
        });
        document.getElementById('gameCanvas').appendChild(app.view);

        // Game variables
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const MOVE_SPEED = 3;
        const AI_UPDATE_RATE = 5; // Update AI every 5 frames

        // Create game containers
        const worldContainer = new PIXI.Container();
        const backgroundContainer = new PIXI.Container();
        const terrainContainer = new PIXI.Container();
        const obstacleContainer = new PIXI.Container();
        const playerContainer = new PIXI.Container();
        worldContainer.addChild(backgroundContainer, terrainContainer, obstacleContainer, playerContainer);
        app.stage.addChild(worldContainer);

        // Advanced AI class
        class AdvancedAI {
            constructor(player, otherPlayer) {
                this.player = player;
                this.otherPlayer = otherPlayer;
                this.jumpCooldown = 0;
            }

            makeDecision() {
                const terrainAhead = this.analyzeTerrainAhead();
                const nearestObstacle = this.findNearestObstacle();
                const competitorPosition = this.analyzeCompetitorPosition();

                let jumpProbability = 0;

                // Terrain-based decision
                if (terrainAhead < -20) jumpProbability += 0.4; // Approaching a cliff
                else if (terrainAhead > 20) jumpProbability += 0.3; // Approaching an uphill

                // Obstacle-based decision
                if (nearestObstacle && nearestObstacle.distance < 100) {
                    jumpProbability += 0.6;
                }

                // Competitor-based decision
                if (competitorPosition > 50) jumpProbability += 0.2; // Try to catch up

                // Random factor for unpredictability
                jumpProbability += Math.random() * 0.1;

                // Perform jump if probability is high enough and not on cooldown
                if (jumpProbability > 0.7 && this.jumpCooldown <= 0 && !this.player.jumping) {
                    this.player.vy = JUMP_FORCE;
                    this.player.jumping = true;
                    this.jumpCooldown = 30; // Set a cooldown to prevent continuous jumping
                }

                // Decrease jump cooldown
                if (this.jumpCooldown > 0) this.jumpCooldown--;
            }

            analyzeTerrainAhead() {
                const currentIndex = Math.floor(this.player.x / terrainResolution);
                const aheadIndex = Math.floor((this.player.x + 100) / terrainResolution);
                if (currentIndex >= 0 && currentIndex < terrainPoints.length &&
                    aheadIndex >= 0 && aheadIndex < terrainPoints.length) {
                    return terrainPoints[currentIndex].y - terrainPoints[aheadIndex].y;
                }
                return 0;
            }

            findNearestObstacle() {
                const nearObstacles = obstacles.filter(obs =>
                    obs.x > this.player.x && obs.x < this.player.x + 300
                );
                if (nearObstacles.length > 0) {
                    const nearest = nearObstacles.reduce((prev, current) =>
                        (current.x - this.player.x < prev.x - this.player.x) ? current : prev
                    );
                    return { obstacle: nearest, distance: nearest.x - this.player.x };
                }
                return null;
            }

            analyzeCompetitorPosition() {
                return this.otherPlayer.x - this.player.x;
            }
        }

        // AI Players
        function createPlayer(color, x, name) {
            const player = new PIXI.Graphics();
            player.beginFill(color);
            player.drawRect(-15, -25, 30, 50);
            player.endFill();
            player.x = x;
            player.y = app.screen.height - 50;
            player.vy = 0;
            player.jumping = false;
            player.score = 0;
            player.name = name;
            playerContainer.addChild(player);
            return player;
        }

        const player1 = createPlayer(0xFF0000, 100, "Red");
        const player2 = createPlayer(0x0000FF, 50, "Blue");
        const ai1 = new AdvancedAI(player1, player2);
        const ai2 = new AdvancedAI(player2, player1);

        // Terrain and Obstacles
        const terrainWidth = 50000;
        const terrainResolution = 100;
        const terrainPoints = [];
        const obstacles = [];
        let terrainGraphics;

        // Game state
        let gameState = 'start';
        let cameraX = 0;

        // Generate smooth terrain with obstacles
        function generateTerrain() {
            terrainPoints.length = 0;
            obstacles.length = 0;
            let y = app.screen.height - 100;

            for (let x = 0; x < terrainWidth; x += terrainResolution) {
                y += (Math.random() - 0.5) * 50;
                y = Math.max(100, Math.min(app.screen.height - 50, y));
                terrainPoints.push(new PIXI.Point(x, y));

                // Add obstacles randomly
                if (Math.random() < 0.1 && x > 1000) {
                    obstacles.push({
                        x: x,
                        y: y - 40,
                        width: 30,
                        height: 40
                    });
                }
            }

            // Ensure the terrain slopes upward overall
            for (let i = 1; i < terrainPoints.length; i++) {
                terrainPoints[i].y = Math.min(terrainPoints[i].y, terrainPoints[i-1].y + 20);
            }
        }

        // Draw terrain and obstacles
        function drawTerrainAndObstacles() {
            if (terrainGraphics) {
                terrainContainer.removeChild(terrainGraphics);
            }
            obstacleContainer.removeChildren();

            terrainGraphics = new PIXI.Graphics();

            // Draw terrain body
            terrainGraphics.beginFill(0x5b3e26);
            terrainGraphics.moveTo(terrainPoints[0].x, app.screen.height);
            terrainPoints.forEach(point => terrainGraphics.lineTo(point.x, point.y));
            terrainGraphics.lineTo(terrainPoints[terrainPoints.length - 1].x, app.screen.height);
            terrainGraphics.endFill();

            // Draw grass
            terrainGraphics.lineStyle(2, 0x2e8b57);
            for (let i = 0; i < terrainPoints.length - 1; i++) {
                const x1 = terrainPoints[i].x;
                const y1 = terrainPoints[i].y;
                const x2 = terrainPoints[i + 1].x;
                const y2 = terrainPoints[i + 1].y;

                for (let j = 0; j < 5; j++) {
                    const x = x1 + (x2 - x1) * (j / 5);
                    const y = y1 + (y2 - y1) * (j / 5);
                    terrainGraphics.moveTo(x, y);
                    terrainGraphics.lineTo(x, y - Math.random() * 5 - 2);
                }
            }

            terrainContainer.addChild(terrainGraphics);

            // Draw obstacles
            obstacles.forEach(obstacle => {
                const obstacleGraphics = new PIXI.Graphics();
                obstacleGraphics.beginFill(0xFF0000);
                obstacleGraphics.drawRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                obstacleGraphics.endFill();
                obstacleContainer.addChild(obstacleGraphics);
            });
        }

        // Background with parallax effect
        function createBackground() {
            const skyGradient = new PIXI.Graphics();
            skyGradient.beginFill(0x87CEEB);
            skyGradient.drawRect(0, 0, terrainWidth, app.screen.height);
            skyGradient.endFill();
            backgroundContainer.addChild(skyGradient);

            for (let i = 0; i < terrainWidth / 500; i++) {
                const mountain = new PIXI.Graphics();
                mountain.beginFill(0x6a8ea6);
                mountain.moveTo(0, app.screen.height);
                for (let x = 0; x <= 600; x++) {
                    const y = Math.sin(x / 100 + i) * 50 + Math.sin(x / 50) * 25;
                    mountain.lineTo(x, app.screen.height - 100 - y);
                }
                mountain.lineTo(600, app.screen.height);
                mountain.endFill();
                mountain.x = i * 500;
                mountain.tint = 0x6a8ea6 - (i % 3) * 0x111111;
                backgroundContainer.addChild(mountain);
            }
        }

        // Check for collision with obstacles
        function checkObstacleCollision(player) {
            return obstacles.some(obstacle =>
                player.x + 15 > obstacle.x &&
                player.x - 15 < obstacle.x + obstacle.width &&
                player.y > obstacle.y &&
                player.y - 50 < obstacle.y + obstacle.height
            );
        }

        // Update game state
        function update(delta) {
            if (gameState === 'playing') {
                [player1, player2].forEach((player, index) => {
                    // Apply gravity
                    player.vy += GRAVITY;
                    player.y += player.vy;

                    // Move player
                    player.x += MOVE_SPEED;

                    // Check ground collision
                    const terrainIndex = Math.floor(player.x / terrainResolution);
                    if (terrainIndex >= 0 && terrainIndex < terrainPoints.length) {
                        const groundHeight = terrainPoints[terrainIndex].y;
                        if (player.y > groundHeight) {
                            player.y = groundHeight;
                            player.vy = 0;
                            player.jumping = false;
                        }
                    }

                    // Check obstacle collision
                    if (checkObstacleCollision(player)) {
                        player.x -= MOVE_SPEED * 5;
                        player.score = Math.max(0, player.score - 10);
                    }

                    // AI decision making
                    if (app.ticker.lastTime % AI_UPDATE_RATE === 0) {
                        if (index === 0) ai1.makeDecision();
                        else ai2.makeDecision();
                    }

                    // Update score
                    player.score = Math.max(0, Math.floor(player.x / 10));
                });

                // Update camera position to follow the leading player
                const leadingPlayer = player1.x > player2.x ? player1 : player2;
                cameraX = leadingPlayer.x - app.screen.width / 3;
                worldContainer.x = -cameraX;
                backgroundContainer.x = -cameraX * 0.5;

                // Check for game over condition
                if (Math.max(player1.x, player2.x) >= terrainWidth - 100) {
                    gameState = 'gameOver';
                    const winner = player1.x > player2.x ? player1 : player2;
                    console.log(`Game Over! ${winner.name} wins with a score of ${winner.score}!`);
                }
            }
        }

        // Setup game
        function setup() {
            createBackground();
            generateTerrain();
            drawTerrainAndObstacles();

            app.ticker.add(update);

            // Event listeners
            window.addEventListener('click', startGame);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    startGame();
                }
            });
        }

        function startGame() {
            if (gameState === 'start' || gameState === 'gameOver') {
                gameState = 'playing';
                player1.x = 100;
                player1.y = app.screen.height - 50;
                player1.vy = 0;
                player1.score = 0;
                player2.x = 50;
                player2.y = app.screen.height - 50;
                player2.vy = 0;
                player2.score = 0;
                cameraX = 0;
                worldContainer.x = 0;
                backgroundContainer.x = 0;
            }
        }

        // Start the game
        setup();
    </script>
</body>
</html>